[{"content":"Problem: https://codeforces.com/contest/1849/problem/E\nSolution: First, for each element we can find the right most position j \u0026lt; i and a[j] greater than or less than a[i] using two monotonic stacks. Next, consider all postition r from left to right and maintain a dp array, for a fixed r define dp[l] = 1 if the segment [l, r] is considered a good segment, otherwise dp[i] = 0.\nNow, let\u0026rsquo;s observe how the dp array changes after we increase r by 1. This can divided into 2 cases based on the relationship between a[i] and a[i-1], those are a[i-1] \u0026lt; a[i] and a[i-1] \u0026gt; a[i]. To understand the transtions in these cases, take some time to analyze them yourself. By following these steps, we can efficiently find the solution to the problem.\nCode: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define ii pair\u0026lt;int, int\u0026gt; #define fi first #define se second using namespace std; const int MAXN = 2e5 + 6; const int MOD = 1e9 + 7; struct tree_node { int val; tree_node() { // default value val = 0; } }; struct segmentTree { int n; vector\u0026lt;int\u0026gt; a; vector\u0026lt;tree_node\u0026gt; tree; vector\u0026lt;bool\u0026gt; cLazy; vector\u0026lt;int\u0026gt; lazy; segmentTree(int n) { this-\u0026gt;n = n; a.resize(n); tree.resize(4 * n + 5); cLazy.assign(4 * n + 5, false); lazy.assign(4 * n + 5, 0); } void propagate(int node, int s, int e) { if (s != e) { cLazy[node * 2] = 1; cLazy[node * 2 + 1] = 1; lazy[node * 2] = lazy[node]; lazy[node * 2 + 1] = lazy[node]; } tree[node].val = (e - s + 1) * lazy[node]; cLazy[node] = 0; } tree_node combine(tree_node i1, tree_node i2) { // Change this combine function // according to the question // Example - max , min, sum // If T change this will change tree_node result; result.val = i1.val + i2.val; return result; } void build(int s, int e, int node) { if (s == e) tree[node].val = a[s]; else { int mid = (s + e) / 2; build(s, mid, 2 * node); build(mid + 1, e, 2 * node + 1); tree[node] = combine(tree[2 * node], tree[2 * node + 1]); } } void update(int l, int r, int val, int s, int e, int node) { if (cLazy[node]) propagate(node, s, e); if (r \u0026lt; s || l \u0026gt; e) return; if (l \u0026lt;= s \u0026amp;\u0026amp; e \u0026lt;= r) { cLazy[node] = 1; lazy[node] = val; propagate(node, s, e); return; } int mid = (s + e) / 2; update(l, r, val, s, mid, node * 2); update(l, r, val, mid + 1, e, node * 2 + 1); tree[node] = combine(tree[2 * node], tree[2 * node + 1]); } tree_node query(int l, int r, int s, int e, int node) { if (cLazy[node]) propagate(node, s, e); if (s \u0026gt; r || e \u0026lt; l) return tree_node(); if (s \u0026gt;= l \u0026amp;\u0026amp; e \u0026lt;= r) return tree[node]; int mid = (s + e) / 2; tree_node left_result = query(l, r, s, mid, 2 * node); tree_node right_result = query(l, r, mid + 1, e, 2 * node + 1); tree_node result = combine(left_result, right_result); return result; } void build() { build(0, n - 1, 1); } void update(int pos, int val) { update(pos, pos, val, 0, n - 1, 1); } void update(int l, int r, int val) { update(l, r, val, 0, n - 1, 1); } tree_node query(int l, int r) { return query(l, r, 0, n - 1, 1); } }; /* How to Use - segmentTree seg(n); // n is the size of array seg.a = v; // Array seg.build(); // Build the tree seg.update(l,r,val); // a[l] = a[l+1] = ... = a[r] = val seg.update(pos,val); // do a[pos] = val seg.query(l,r); // get sum Zero Based Indexing in Array and 1 Based Indexing in Tree */ int main(int argc, char const *argv[]) { cin.tie(0)-\u0026gt;sync_with_stdio(0); if (fopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;)) { freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); } int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n + 1); stack\u0026lt;int\u0026gt; minStack, maxStack; vector\u0026lt;int\u0026gt; lMin(n + 1), lMax(n + 1); for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; // lMin[i] right most index j \u0026lt; i that a[j] \u0026lt; a[i] while (minStack.size() \u0026amp;\u0026amp; a[minStack.top()] \u0026gt;= a[i]) { minStack.pop(); } if (!minStack.size()) lMin[i] = 0; else lMin[i] = minStack.top(); minStack.push(i); // lMax[i] right most index j \u0026lt; i that a[j] \u0026gt; a[i] while (maxStack.size() \u0026amp;\u0026amp; a[maxStack.top()] \u0026lt;= a[i]) { maxStack.pop(); } if (!maxStack.size()) lMax[i] = 0; else lMax[i] = maxStack.top(); maxStack.push(i); } segmentTree tree(n); ll ans = 0; for (int i = 2; i \u0026lt;= n; i++) { if (a[i] \u0026gt; a[i - 1]) { tree.update(lMax[i] + 1, i - 1, 1); } else { tree.update(lMin[i] + 1, i - 1, 0); } ans += tree.query(1, i - 1).val; } cout \u0026lt;\u0026lt; ans; return 0; } ","date":"2023-01-13T00:00:00Z","image":"https://material-art-master.github.io/p/e.-max-to-the-right-of-min/CP_hue11b2ba56b08fdca03eb474b3b557450_17864_120x120_fill_q75_box_smart1.jpg","permalink":"https://material-art-master.github.io/p/e.-max-to-the-right-of-min/","title":"E. Max to the Right of Min"},{"content":"Problem: https://codeforces.com/contest/1775/problem/F\nSolution: First, calculate the minimum perimeter of the lab. Then, for all rectangles with the perimeter equal to the minimum perimeter and area $\\ge n$, determine the number of ways to remove some stair-shaped figures from 4 corners that have a total area equal to $n - xy (n - xy \\le \\sqrt{n})$. This\u0026rsquo;s the final answer.\nTo determine this, consider the sub-problem of selecting a stair-shaped figure in one corner. We can find that the number of ways to choose a figure of area $n$ is equivalent to the problem of \u0026ldquo;How many ways to construct a increasing sequence of sum $n$?\u0026rdquo;, also known as partition. This problem can be solved by using DP($O(n(n)$) or the formula $p[n] = \\sum_{i \\neq 0}(p[n+(-1)^{i}i(3i-1)/2])$. The final anwser is the number of ways to choose 4 stair-shaped figures in 4 corners which equivalent to the 4th convolution power of the above sequence.\nOfficial solution: link YocyCraft\u0026rsquo;s solution: link Code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 #include \u0026lt;bits/stdc++.h\u0026gt; #define fi first #define se second #define ll long long #define ld long double #define ii pair\u0026lt;int, int\u0026gt; #define FOR(i,a,b) for (int i=a; i\u0026lt;=b; ++i) #define FORD(i,b,a) for (int i=b; i\u0026gt;=a; --i) using namespace std; const int MAXN = 4e5+6; const int SQRTN = 1400; const int MOD = 1e9+7; ll M; vector\u0026lt;ll\u0026gt; conv; void calcConvolution() { int n = SQRTN - 1; vector\u0026lt;ll\u0026gt; f(n+1); //find the partitions array //https://en.wikipedia.org/wiki/Partition_(number_theory) f[0] = 1; FOR(i,1,n) { FOR(j,i,n) { f[j]+= f[j-i]; f[j] %= M; } } conv = f; //calculate the 4th convolution power of the partitions array FOR(i,2,4) { int n = conv.size() - 1; int m = f.size() - 1; vector\u0026lt;ll\u0026gt; newConv(n + m + 1); FOR(j,0,n) { FOR(k,0,j) { if (j - k \u0026lt;= m) { newConv[j] += 1ll * conv[k] * f[j - k]; newConv[j] %= M; } } } swap(conv, newConv); newConv.clear(); } } void solve1(int n) { int y = sqrt(n); y+= (y*y \u0026lt; n); int x = (n/y) + ((n%y) \u0026gt; 0); vector\u0026lt;vector\u0026lt;char\u0026gt; \u0026gt; ans; int nBlocks = 0; FOR(i,1,x) { ans.push_back(vector\u0026lt;char\u0026gt;(y)); FOR(j,1,y) { if (nBlocks \u0026lt; n) ans[i-1][j-1] = \u0026#39;#\u0026#39;; else ans[i-1][j-1] = \u0026#39;.\u0026#39;; nBlocks++; } } cout \u0026lt;\u0026lt; ans.size() \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; ans[0].size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; for(auto \u0026amp;u: ans) { for(auto \u0026amp;v: u) { cout \u0026lt;\u0026lt; v; } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } void solve2(int n) { int y = sqrt(n); y+= (y*y \u0026lt; n); int x = (n/y) + ((n%y) \u0026gt; 0); ll ans = 0; swap(x, y); int minPerimeter = 2*(x+y); //iterate over all pairs (x, y) such that x * y \u0026gt;= n and 2(x+y) equal to the minumum perimeter while (x * y \u0026gt;= n \u0026amp;\u0026amp; x \u0026gt;= y) { //ans = sum of conv[x*y - n] ans+= conv[x*y - n] * (1 + (x != y)); ans%= M; //dont need to recalculate minumum perimeter // minPerimeter = min(minPerimeter, 2*(x + y)); x++; y--; } cout \u0026lt;\u0026lt; minPerimeter \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main(int argc, char const *argv[]) { cin.tie(0)-\u0026gt;sync_with_stdio(0); if (fopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;)){ freopen(\u0026#34;input.txt\u0026#34;,\u0026#34;r\u0026#34;,stdin); } int t, u; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; u; if (u==2) { cin \u0026gt;\u0026gt; M; calcConvolution(); } while (t--) { int n; cin \u0026gt;\u0026gt; n; if (u\u0026amp;1) solve1(n); else solve2(n); } return 0; } ","date":"2023-01-13T00:00:00Z","image":"https://material-art-master.github.io/p/f.-laboratory-on-pluto/image_hue7040bb7b49a4cbafc197a682fc6cf32_35400_120x120_fill_box_smart1_3.png","permalink":"https://material-art-master.github.io/p/f.-laboratory-on-pluto/","title":"F. Laboratory on Pluto"},{"content":"Problem: https://codeforces.com/contest/1746/problem/F\nSolution: Code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 //https://codeforces.com/contest/1746/problem/F #include \u0026lt;bits/stdc++.h\u0026gt; #define fi first #define se second #define ll long long #define ld long double #define ii pair\u0026lt;int, int\u0026gt; #define FOR(i,a,b) for (int i=a; i\u0026lt;=b; ++i) #define FORD(i,b,a) for (int i=b; i\u0026gt;=a; --i) using namespace std; const int MAX = 3e5+6; const int MOD = 1e9+7; struct FT { vector\u0026lt;ll\u0026gt; s; FT(int n) : s(n) {} void update(int pos, ll dif) { // a[pos] += dif for (; pos \u0026lt; s.size(); pos |= pos + 1) s[pos] += dif; } ll query(int pos) { // sum of values in [0, pos) ll res = 0; for (; pos \u0026gt; 0; pos \u0026amp;= pos - 1) res += s[pos-1]; return res; } int lower_bound(ll sum) {// min pos st sum of [0, pos] \u0026gt;= sum // Returns n if no sum is \u0026gt;= sum, or -1 if empty sum is. if (sum \u0026lt;= 0) return -1; int pos = 0; for (int pw = 1 \u0026lt;\u0026lt; 25; pw; pw \u0026gt;\u0026gt;= 1) { if (pos + pw \u0026lt;= s.size() \u0026amp;\u0026amp; s[pos + pw-1] \u0026lt; sum) pos += pw, sum -= s[pos-1]; } return pos; } }; int n, q; int a[MAX]; vector\u0026lt;int\u0026gt; B; vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt; \u0026gt; Q; vector\u0026lt; vector\u0026lt;bool\u0026gt; \u0026gt; S; int compressedValue(int x) { return lower_bound(B.begin(), B.end(), x) - B.begin() + 1; } void generateSubsets() { mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());//64-bit number generator S.resize(30); FOR(i,0, 30 - 1) { S[i].resize(B.size()+6, 0); FOR(j,0, S[i].size()-1) { S[i][j] = rng() % 2; } } } int main(int argc, char const *argv[]) { cin.tie(0)-\u0026gt;sync_with_stdio(0); if (fopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;)){ freopen(\u0026#34;input.txt\u0026#34;,\u0026#34;r\u0026#34;,stdin); } cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; FOR(i,1,n) cin \u0026gt;\u0026gt; a[i], B.push_back(a[i]); FOR(i,1,q) { int Type; cin \u0026gt;\u0026gt; Type; if (Type==1) { int pos, x; cin \u0026gt;\u0026gt; pos \u0026gt;\u0026gt; x; Q.push_back({0, pos, x}); B.push_back(x); } else { int l, r, k; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k; Q.push_back({l, r, k}); } } sort(B.begin(), B.end()); FOR(i,1,n) a[i] = compressedValue(a[i]); generateSubsets(); vector\u0026lt;FT\u0026gt; ft(30, FT(n + 10)); for(int i = 0 ; i \u0026lt; 30; i ++) { for(int j = 1; j \u0026lt;=n; j++) { if (S[i][(a[j])]) { ft[i].update(j, 1); } } } for(auto \u0026amp;query: Q) { if (get\u0026lt;0\u0026gt;(query) == 0) { auto [_, i, x] = query; x = compressedValue(x); for(int j = 0; j \u0026lt; 30; j++) { if (S[j][(a[i])] == S[j][x]) continue; else if (S[j][(a[i])]) { ft[j].update(i, -1); } else { ft[j].update(i, 1); } } a[i] = x; } else { auto [l, r, k] = query; bool ans = true; r++; l++; for(int i = 0; i \u0026lt; 30; i++) { if ((ft[i].query(r) - ft[i].query(l-1)) % k != 0) ans = false; } if (ans) cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; } } return 0; } ","date":"2023-01-09T00:00:00Z","image":"https://material-art-master.github.io/p/codeforces-1746f.-kazaee/CP_hue11b2ba56b08fdca03eb474b3b557450_17864_120x120_fill_q75_box_smart1.jpg","permalink":"https://material-art-master.github.io/p/codeforces-1746f.-kazaee/","title":"Codeforces 1746F. Kazaee"},{"content":"Problem: https://codeforces.com/contest/1771/problem/F\nSolution: The problem asked us to find the smallest number in a given sequence, which occurs an odd number of times in online. To solve this problem, we can use a persistent segment tree with binary search or walk on segment tree technique to solve the problem. But it has a probability of xor of some number equal to 0 (Like 1 xor 2 xor 3). To prevent it, we can just simply map each number with a random 64-bit number.\nCode: Using binary search 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #include \u0026lt;bits/stdc++.h\u0026gt; #define fi first #define se second #define ll long long #define ld long double #define ii pair\u0026lt;int, int\u0026gt; #define FOR(i,a,b) for (int i=a; i\u0026lt;=b; ++i) #define FORD(i,b,a) for (int i=b; i\u0026gt;=a; --i) using namespace std; const int MAX = 2e5+6; const int MOD = 1e9+7; struct Vertex { Vertex *l, *r; int sum; Vertex(int val) : l(nullptr), r(nullptr), sum(val) {} Vertex(Vertex *l, Vertex *r) : l(l), r(r), sum(0) { if (l) sum ^= l-\u0026gt;sum; if (r) sum ^= r-\u0026gt;sum; } }; Vertex* build(vector\u0026lt;int\u0026gt; \u0026amp;a, int tl, int tr) { if (tl == tr) return new Vertex(a[tl]); int tm = (tl + tr) / 2; return new Vertex(build(a, tl, tm), build(a, tm+1, tr)); } int get_sum(Vertex* v, int tl, int tr, int l, int r) { if (l \u0026gt; r) return 0; if (l == tl \u0026amp;\u0026amp; tr == r) return v-\u0026gt;sum; int tm = (tl + tr) / 2; return get_sum(v-\u0026gt;l, tl, tm, l, min(r, tm)) + get_sum(v-\u0026gt;r, tm+1, tr, max(l, tm+1), r); } Vertex* update(Vertex* v, int tl, int tr, int pos, int new_val) { if (tl == tr) return new Vertex(new_val^v-\u0026gt;sum); int tm = (tl + tr) / 2; if (pos \u0026lt;= tm) return new Vertex(update(v-\u0026gt;l, tl, tm, pos, new_val), v-\u0026gt;r); else return new Vertex(v-\u0026gt;l, update(v-\u0026gt;r, tm+1, tr, pos, new_val)); } int main(int argc, char const *argv[]) { cin.tie(0)-\u0026gt;sync_with_stdio(0); if (fopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;)){ freopen(\u0026#34;input.txt\u0026#34;,\u0026#34;r\u0026#34;,stdin); } mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());//64-bit number generator int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n+1), b(n+1); FOR(i,1,n) { cin \u0026gt;\u0026gt; b[i]; a[i] = b[i]; } sort(b.begin()+1, b.end());//b is the original a FOR(i,1,n) a[i] = lower_bound(b.begin()+1, b.end(), a[i]) - b.begin(); vector\u0026lt;int\u0026gt; tmp(n+1, 0); vector\u0026lt;Vertex*\u0026gt; roots(n+1); roots[0] = build(tmp, 1, n); FOR(i,1,n) tmp[i] = rng(); FOR(i,1,n) { roots[i] = update(roots[i-1],1,n,a[i],tmp[a[i]]); } int res = 0; int Q, ql, qr; cin \u0026gt;\u0026gt; Q; while (Q--) { cin \u0026gt;\u0026gt; ql \u0026gt;\u0026gt; qr; ql^= res; qr^= res; int l = 1, r = n, found = false; while (l\u0026lt;=r) { int mid = (l+r)/2; if (get_sum(roots[qr], 1, n, 1, mid)^get_sum(roots[ql-1], 1, n, 1, mid)) { found = true; r = mid-1; res = mid; } else l = mid+1; } res = b[res]; if (!found) res = 0; cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } Using walk on segment tree 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 #include \u0026lt;bits/stdc++.h\u0026gt; #define fi first #define se second #define ll long long #define ld long double #define ii pair\u0026lt;int, int\u0026gt; #define FOR(i,a,b) for (int i=a; i\u0026lt;=b; ++i) #define FORD(i,b,a) for (int i=b; i\u0026gt;=a; --i) using namespace std; const int MAX = 2e5+6; const int MOD = 1e9+7; struct Vertex { Vertex *l, *r; int sum; Vertex(int val) : l(nullptr), r(nullptr), sum(val) {} Vertex(Vertex *l, Vertex *r) : l(l), r(r), sum(0) { if (l) sum ^= l-\u0026gt;sum; if (r) sum ^= r-\u0026gt;sum; } }; Vertex* build(vector\u0026lt;int\u0026gt; \u0026amp;a, int tl, int tr) { if (tl == tr) return new Vertex(a[tl]); int tm = (tl + tr) / 2; return new Vertex(build(a, tl, tm), build(a, tm+1, tr)); } int get_sum(Vertex* v, int tl, int tr, int l, int r) { if (l \u0026gt; r) return 0; if (l == tl \u0026amp;\u0026amp; tr == r) return v-\u0026gt;sum; int tm = (tl + tr) / 2; return get_sum(v-\u0026gt;l, tl, tm, l, min(r, tm)) + get_sum(v-\u0026gt;r, tm+1, tr, max(l, tm+1), r); } int query(Vertex *vl, Vertex *vr, int tl, int tr) { //find the first position x such that sum_xor[1..x] != 0 if (tl==tr) { if (vr-\u0026gt;sum ^ vl-\u0026gt;sum) return tl; else return 0; } int tm = (tl + tr)/2; int left_xor_sum = vr-\u0026gt;l-\u0026gt;sum ^ vl-\u0026gt;l-\u0026gt;sum; if (left_xor_sum) { return query(vl-\u0026gt;l, vr-\u0026gt;l, tl, tm); } else return query(vl-\u0026gt;r, vr-\u0026gt;r, tm+1, tr); } Vertex* update(Vertex* v, int tl, int tr, int pos, int new_val) { if (tl == tr) return new Vertex(new_val^v-\u0026gt;sum); int tm = (tl + tr) / 2; if (pos \u0026lt;= tm) return new Vertex(update(v-\u0026gt;l, tl, tm, pos, new_val), v-\u0026gt;r); else return new Vertex(v-\u0026gt;l, update(v-\u0026gt;r, tm+1, tr, pos, new_val)); } int main(int argc, char const *argv[]) { cin.tie(0)-\u0026gt;sync_with_stdio(0); if (fopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;)){ freopen(\u0026#34;input.txt\u0026#34;,\u0026#34;r\u0026#34;,stdin); } mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());//64-bit number generator int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n+1), b(n+1); FOR(i,1,n) { cin \u0026gt;\u0026gt; b[i]; a[i] = b[i]; } sort(b.begin()+1, b.end());//b is the original a FOR(i,1,n) a[i] = lower_bound(b.begin()+1, b.end(), a[i]) - b.begin(); vector\u0026lt;int\u0026gt; tmp(n+1, 0); vector\u0026lt;Vertex*\u0026gt; roots(n+1); roots[0] = build(tmp, 1, n); FOR(i,1,n) tmp[i] = rng(); FOR(i,1,n) { roots[i] = update(roots[i-1],1,n,a[i],tmp[a[i]]); } int res = 0; int Q, ql, qr; cin \u0026gt;\u0026gt; Q; while (Q--) { cin \u0026gt;\u0026gt; ql \u0026gt;\u0026gt; qr; ql^= res; qr^= res; res = query(roots[ql-1], roots[qr],1,n); res = b[res]; cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } ","date":"2022-12-17T00:00:00Z","image":"https://material-art-master.github.io/p/codeforces-1771f.-hossam-and-range-minimum-query/CP_hue11b2ba56b08fdca03eb474b3b557450_17864_120x120_fill_q75_box_smart1.jpg","permalink":"https://material-art-master.github.io/p/codeforces-1771f.-hossam-and-range-minimum-query/","title":"Codeforces 1771F. Hossam and Range Minimum Query"},{"content":"Problem: https://atcoder.jp/contests/arc074/tasks/arc074_c\nSolution: Let\u0026rsquo;s $dp[r][g][b]$ is the number of ways to paint the sequence with $r, g, b$ is the last position corresponding to each color. We can see that the current position we are considering is $max(r,g,b)$ Let\u0026rsquo;s $i = max(r,g,b)$ then we can also check every constraint with right-endpoint at the position $i$. The rest of the problem is very easy to do.\nCode: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 //prob: https://atcoder.jp/contests/arc074/tasks/arc074_c #include \u0026lt;bits/stdc++.h\u0026gt; #define fi first #define se second #define ll long long #define ld long double #define ii pair\u0026lt;int, int\u0026gt; #define FOR(i,a,b) for (int i=a; i\u0026lt;=b; ++i) #define FORD(i,b,a) for (int i=b; i\u0026gt;=a; --i) using namespace std; const int MAX = 3e2+6; const int MOD = 1e9+7; vector\u0026lt;ii\u0026gt; constraints[MAX]; int dp[MAX][MAX][MAX]; bool Check(int r, int g, int b, int cur_pos) { for(auto \u0026amp;tmp: constraints[cur_pos]) { int l = tmp.fi, x = tmp.se, cnt = 0; if (r \u0026gt;= l) cnt++; if (g \u0026gt;= l) cnt++; if (b \u0026gt;= l) cnt++; if (cnt != x) return false; } return true; } int main(int argc, char const *argv[]) { cin.tie(0)-\u0026gt;sync_with_stdio(0); if (fopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;)){ freopen(\u0026#34;input.txt\u0026#34;,\u0026#34;r\u0026#34;,stdin); } int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; FOR(i,1,m) { int l, r, x; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; x; constraints[r].push_back({l,x}); } if (Check(1,0,0,1)) dp[1][0][0] = dp[0][1][0] = dp[0][0][1] = 1; int res = 0; FOR(r,0,n) { FOR(g,0,n) { FOR(b,0,n) { int i = max({r,g,b}); if (Check(i+1,g,b, i+1)) { dp[i+1][g][b]+= dp[r][g][b]; dp[i+1][g][b]%= MOD; } if (Check(r,i+1,b, i+1)) { dp[r][i+1][b]+= dp[r][g][b]; dp[r][i+1][b]%= MOD; } if (Check(r,g,i+1, i+1)) { dp[r][g][i+1]+= dp[r][g][b]; dp[r][g][i+1]%= MOD; } if (i==n) { res+= dp[r][g][b]; res%= MOD; } } } } cout \u0026lt;\u0026lt; res; return 0; } ","date":"2022-12-17T00:00:00Z","image":"https://material-art-master.github.io/p/e-rgb-sequence/CP_hue11b2ba56b08fdca03eb474b3b557450_17864_120x120_fill_q75_box_smart1.jpg","permalink":"https://material-art-master.github.io/p/e-rgb-sequence/","title":"E - RGB Sequence"}]